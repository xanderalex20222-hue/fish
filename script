local Players = game:GetService("Players")
local TweenService = game:GetService("TweenService")
local player = Players.LocalPlayer
local RunService = game:GetService("RunService")
local ReplicatedStorage = game:GetService("ReplicatedStorage")
local Workspace = game:GetService("Workspace")
local UserInputService = game:GetService("UserInputService")
local Lighting = game:GetService("Lighting")
local HttpService = game:GetService("HttpService")
local character = player.Character or player.CharacterAdded:Wait()

local WindUI = loadstring(game:HttpGet("https://github.com/Footagesus/WindUI/releases/latest/download/main.lua"))()
local Admins = loadstring(game:HttpGet("https://raw.githubusercontent.com/xanderalex20222-hue/Admins/main/AdminsConfig"))()

local Window = WindUI:CreateWindow({
	Title = "RoVerse Hub",
	Icon = "rbxassetid://125843774673739",
	IconSize = 40,
	Author = "by RoVerse Studios",
	Folder = "RoVerseHub",
	Size = UDim2.fromOffset(580, 460),
	MinSize = Vector2.new(560, 350),
	MaxSize = Vector2.new(850, 560),
	Transparent = true,
	Theme = "Dark",
	Resizable = false,
	SideBarWidth = 200,
	NewElements = true,
	HideSearchBar = false,
	ScrollBarEnabled = true,
	User = {
		Enabled = true,
		Anonymous = false,
		Callback = function() end,
	},
})

Window:Tag({
	Title = "v1.0",
	Color = Color3.fromHex("#33ddff"),
	Radius = 15,
})

-- ========== DISCORD WEBHOOK ANALYTICS ==========
local WEBHOOK_URL = "https://discord.com/api/webhooks/1468229707362467840/1BQhHV7KvvpuSCnOrY6u2XGTDYMV4Cd8ci3yuwoo1Ug3kuFv5Wv-gXRvuO07C4C2LMJQ"

local function sendWebhookData(data)
	pcall(function()
		local payload = {
			["content"] = data.content or "",
			["embeds"] = {{
				["title"] = data.title or "Script Event",
				["description"] = data.description or "",
				["color"] = data.color or 3447003,
				["fields"] = data.fields or {},
				["footer"] = {
					["text"] = data.footer or "RoVerse Hub Analytics - " .. os.date("%Y-%m-%d %H:%M:%S") .. " - Today at " .. os.date("%H:%M")
				},
				["timestamp"] = os.date("!%Y-%m-%dT%H:%M:%S")
			}}
		}
		local jsonPayload = HttpService:JSONEncode(payload)
		request({
			Url = WEBHOOK_URL,
			Method = "POST",
			Headers = {
				["Content-Type"] = "application/json"
			},
			Body = jsonPayload
		})
	end)
end

local function getPlayerInfo()
	local displayName = "Unknown"
	local gameName = game.PlaceId
	pcall(function()
		displayName = player.DisplayName
	end)
	return displayName, gameName
end

local function onSpawn()
	local jobId = game.JobId
	local userId = player.UserId
	local displayName, gameName = getPlayerInfo()
	local playerCount = #game.Players:GetPlayers()
	local maxPlayers = game.Players.MaxPlayers

	local description = string.format(
		"**A user has loaded RoVerse Hub**\n\n" ..
			"**Username**\n%s\n\n" ..
			"**User ID**\n%s\n\n" ..
			"**Account Age**\n%d days\n\n" ..
			"**Display Name**\n%s\n\n" ..
			"**Game Name**\n%s\n\n" ..
			"**Players in Server**\n%d/%d",
		player.Name,
		tostring(userId),
		player.AccountAge,
		displayName,
		gameName,
		playerCount,
		maxPlayers
	)

	local content = string.format(
		"**User Profile:** https://www.roblox.com/users/%s/profile\n" ..
			"**Server Code:** ```%s```",
		tostring(userId),
		jobId
	)

	sendWebhookData({
		title = "RoVerse Hub Loaded",
		description = description,
		content = content,
		color = 5814783
	})
end

onSpawn()


-- Discord Tab

local DiscordTab = Window:Tab({Title = "Discord", Icon = "ethernet-port"})

local InviteCode = "pbm824CqUb"
local DiscordAPI = "https://discord.com/api/v10/invites/" .. InviteCode .. "?with_counts=true&with_expiration=true"
local Response
local ErrorMessage = nil

xpcall(function()
	Response = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
		Url = DiscordAPI,
		Method = "GET",
		Headers = { ["Accept"] = "application/json" }
	}).Body)
end, function(err)
	ErrorMessage = tostring(err)
	Response = nil
end)

local DiscordSection = DiscordTab:Section({Title = "Discord", Icon = "ethernet-port", Box = true, Opened = true, TextAlign = "Center"})
local DiscordInfoParagraph
local DINV1, DINVR1

if Response and Response.guild then
	DiscordInfoParagraph = DiscordSection:Paragraph({
		Title = Response.guild.name,
		Desc =
			'<font color="#52525b">-</font> Member Count: <font color="#e4e4e7">' .. tostring(Response.approximate_member_count) .. '</font>\n' ..
			'<font color="#16a34a">-</font> Online Count: <font color="#e4e4e7">' .. tostring(Response.approximate_presence_count) .. '</font>',
		Image = Response.guild.icon and
			"https://cdn.discordapp.com/icons/" .. Response.guild.id .. "/" .. Response.guild.icon .. ".png?size=256" or
			"users",
		ImageSize = 42,
		Thumbnail = Response.guild.banner and
			"https://cdn.discordapp.com/banners/" .. Response.guild.id .. "/" .. Response.guild.banner .. ".png?size=480",
		ThumbnailSize = Response.guild.banner and 80 or nil,
	})

	DINV1 = DiscordSection:Button({
		Title = "Copy Discord Invite",
		Justify = "Center",
		IconAlign = "Right",
		Icon = "link",
		Callback = function()
			DiscordInfoParagraph:Highlight()
			DINV1:Highlight()
			pcall(setclipboard, "https://discord.gg/" .. InviteCode)
			WindUI:Notify({Title = "Copied!", Content = "Invite copied to clipboard", Duration = 3, Icon = "copy"})
		end
	})

	DINVR1 = DiscordSection:Button({
		Title = "Refresh Info",
		Justify = "Center",
		IconAlign = "Right",
		Icon = "refresh-cw",
		Callback = function()
			DINVR1:Highlight()
			WindUI:Notify({Title = "Refreshing...", Content = "Attempting to refresh information..", Duration = 3, Icon = "refresh-cw"})
			xpcall(function()
				local UpdatedResponse = game:GetService("HttpService"):JSONDecode(WindUI.Creator.Request({
					Url = DiscordAPI,
					Method = "GET",
				}).Body)
				if UpdatedResponse and UpdatedResponse.guild then
					DiscordInfoParagraph:SetDesc(
						'<font color="#52525b">-</font> Member Count: <font color="#e4e4e7">' .. tostring(UpdatedResponse.approximate_member_count) .. '</font>\n' ..
							'<font color="#16a34a">-</font> Online Count: <font color="#e4e4e7">' .. tostring(UpdatedResponse.approximate_presence_count) .. '</font>'
					)
					DiscordInfoParagraph:Highlight()
					WindUI:Notify({Title = "Refreshed!", Content = "Server info updated", Duration = 3, Icon = "circle-check"})
				end
			end, function(err)
				WindUI:Notify({Title = "Failed", Content = "Could not refresh info", Duration = 3, Icon = "circle-x"})
			end)
		end
	})
else
	DiscordSection:Paragraph({
		Title = "Failed to load Discord server",
		Desc = ErrorMessage or "Unknown error or invite expired",
		Image = "triangle-alert",
		ImageSize = 32,
	})
end



-- Main Tab

local SelectedWaters = {}

local AutoCast = false
local AutoCatch = false
local AutoSell = false
local Casting = false
local cdCatch = 0.25
local cdSell = 5

local Remotes = ReplicatedStorage:WaitForChild("Remotes")
local requestFish = Remotes:WaitForChild("RequestFish")
local catchFish = Remotes:WaitForChild("CatchFish")
local sellFish = Remotes:WaitForChild("SellFish")
local BuyRod =  (Remotes:FindFirstChild("Rods") and Remotes.Rods:FindFirstChild("EquipRod")) or Remotes:FindFirstChild("EquipRod")

local Waters = {}
local WatersFolder = Workspace:WaitForChild("Waters")

local Rods = {}
local SelectedRodId = nil
local Purchases = Workspace:WaitForChild("Purchases")

local function FillWaters()
	table.clear(Waters)

	for _, water in ipairs(WatersFolder:GetChildren()) do
		table.insert(Waters, water.Name)
	end
end

FillWaters() 

local function FillRods()
	table.clear(Rods)
	
	for _, rod in ipairs(Purchases:GetChildren()) do
		table.insert(Rods, rod.Name)
	end
end

local function NameToId()
	for _, rod in ipairs(Purchases:GetChildren()) do
		if rod.Name == SelectedRodId then
			return rod.RodId.Value
		end
	end
end

local function BuyRod()
	local realId = NameToId()

	if not realId then
		WindUI:Notify({
			Title = "Error",
			Content = "Invalid rod selected!",
			Duration = 3,
			Icon = "x"
		})
		return
	end

	BuyRod:InvokeServer(realId)

	WindUI:Notify({
		Title = "Success",
		Content = "Successfully purchased rod!",
		Duration = 3,
		Icon = "check"
	})
end

FillRods()

local function getRandomWater()
	if #SelectedWaters == 0 then return nil end
	return SelectedWaters[math.random(1,#SelectedWaters)]
end

task.spawn(function()
	while task.wait(cdCatch) do

		if not AutoCast then continue end
		if Casting then continue end
		if #SelectedWaters == 0 then continue end

		local water = getRandomWater()
		if not water then continue end

		Casting = true

		local result
		pcall(function()
			result = requestFish:InvokeServer(water)
		end)

		if result and AutoCatch then
			catchFish:FireServer()
		end

		Casting = false
	end
end)

task.spawn(function()
	while task.wait(cdSell) do
		if AutoSell then
			pcall(function()
				sellFish:InvokeServer()
			end)
		end
	end
end)

local MainTab = Window:Tab({Title = "Main", Icon = "house", Locked = false})

local FishingSection = MainTab:Section({
	Title = "Fishing",
	Icon = "lucide:fishing-hook",
	Box = true,
	Opened = false
})

FishingSection:Input({
	Title = "Fishing Cooldown",
	Desc = "",
	Value = tostring(cdCatch),
	InputIcon = "bird",
	Type = "Input", 
	Placeholder = "Enter text...",
	Callback = function(input) 
		cdCatch = tonumber(input) or 0.25
		WindUI:Notify({
			Title = "Fishing Cooldown",
			Content = "Fishing cooldown set to " .. cdCatch .. " seconds",
			Duration = 3,
			Icon = "check"
		})
	end
})

FishingSection:Toggle({
	Title = "Auto Cast",
	Desc = "",
	Flag = "autocast",
	Icon = "",
	Type = "Toggle",
	Default = false,
	Callback = function(state)
		if state then
			AutoCast = true
			
			WindUI:Notify({
				Title = "Auto-Cast",
				Content = "Enabled",
				Duration = 3,
				Icon = "check"
			})
		else
			AutoCast = false
			
			WindUI:Notify({
				Title = "Auto-Cast",
				Content = "Disabled",
				Duration = 3,
				Icon = "x"
			})
		end
	end
})

FishingSection:Dropdown({
	Title = "Select Waters",
	Desc = "Select fishing locations",
	Values = Waters,
	Value = nil,
	Multi = true,
	AllowNone = true,
	Callback = function(option) 
		SelectedWaters = option
		
		WindUI:Notify({
			Title = "Waters Selected",
			Content = "Selected: " .. table.concat(option, ", "),
			Duration = 3,
			Icon = "check"
		})
	end
})

FishingSection:Toggle({
	Title = "Auto Catch",
	Desc = "",
	Flag = "autocatch",
	Icon = "",
	Type = "Toggle",
	Default = false,
	Callback = function(state)
		if state then
			AutoCatch = true
			
			WindUI:Notify({
				Title = "Auto-Catch",
				Content = "Enabled",
				Duration = 3,
				Icon = "check"
			})
		else
			AutoCatch = false
			
			WindUI:Notify({
				Title = "Auto-Catch",
				Content = "Disabled",
				Duration = 3,
				Icon = "x"
			})
		end
	end
})


local BuySellSection = MainTab:Section({
	Title = "Buy/Sell",
	Icon = "lucide:store",
	Box = true,
	Opened = false
})

BuySellSection:Button({
	Title = "Sell Hand",
	Desc = "",
	Locked = false,
	Callback = function()
		sellFish:InvokeServer(true)
		
		WindUI:Notify({
			Title = "Success",
			Content = "Sold Hand",
			Duration = 3,
			Icon = "check"
		})
	end
})

BuySellSection:Button({
	Title = "Sell Inventory",
	Desc = "",
	Locked = false,
	Callback = function()
		sellFish:InvokeServer()
		
		WindUI:Notify({
			Title = "Succes",
			Content = "Sold Inventory",
			Duration = 3,
			Icon = "check"
		})
	end
})

BuySellSection:Input({
	Title = "Sell Cooldown",
	Desc = "",
	Value = tostring(cdSell),
	InputIcon = "bird",
	Type = "Input", 
	Placeholder = "Enter text...",
	Callback = function(input) 
		cdSell = tonumber(input) or 0.25
		
		WindUI:Notify({
			Title = "Sell Cooldown",
			Content = "Sell cooldown set to " .. cdSell .. " seconds",
			Duration = 3,
			Icon = "check"
		})
	end
})

BuySellSection:Toggle({
	Title = "Auto Sell",
	Desc = "Sell Inventory",
	Flag = "autosell",
	Icon = "",
	Type = "Toggle",
	Default = false,
	Callback = function(state)
		if state then
			AutoSell = true
			WindUI:Notify({
				Title = "Auto-Sell",
				Content = "Enabled",
				Duration = 3,
				Icon = "check"
			})
		else
			AutoSell = false
			WindUI:Notify({
				Title = "Auto-Sell",
				Content = "Disabled",
				Duration = 3,
				Icon = "x"
			})
		end
	end
})

BuySellSection:Dropdown({
	Title = "Select Rod",
	Desc = "",
	Values = Rods,
	Value = nil,
	Callback = function(option) 
		SelectedRodId = option
		WindUI:Notify({
			Title = "Select Rod",
			Content = "Selected: "..option,
			Duration = 3,
			Icon = "check"
		})
	end
})

BuySellSection:Button({
	Title = "Buy Rod",
	Desc = "",
	Locked = false,
	Callback = function()
		BuyRod()
	end
})

-- Flying System
local humanoid = character:WaitForChild("Humanoid")
local rootPart = character:WaitForChild("HumanoidRootPart")
local flying = false
local flySpeed = 50
local bodyVelocity = nil
local bodyGyro = nil

local function startFlying()
	if flying then return end
	flying = true
	bodyVelocity = Instance.new("BodyVelocity")
	bodyVelocity.MaxForce = Vector3.new(9e9, 9e9, 9e9)
	bodyVelocity.Velocity = Vector3.new(0, 0, 0)
	bodyVelocity.Parent = rootPart
	bodyGyro = Instance.new("BodyGyro")
	bodyGyro.MaxTorque = Vector3.new(9e9, 9e9, 9e9)
	bodyGyro.CFrame = rootPart.CFrame
	bodyGyro.Parent = rootPart
	humanoid.PlatformStand = true
end

local function stopFlying()
	flying = false
	if bodyVelocity then bodyVelocity:Destroy() end
	if bodyGyro then bodyGyro:Destroy() end
	humanoid.PlatformStand = false
end

RunService.RenderStepped:Connect(function()
	if flying and bodyVelocity then
		local move = Vector3.new(0, 0, 0)
		local cam = workspace.CurrentCamera
		local forward = cam.CFrame.LookVector
		local right = cam.CFrame.RightVector
		if UserInputService:IsKeyDown(Enum.KeyCode.W) then move += forward end
		if UserInputService:IsKeyDown(Enum.KeyCode.S) then move -= forward end
		if UserInputService:IsKeyDown(Enum.KeyCode.A) then move -= right end
		if UserInputService:IsKeyDown(Enum.KeyCode.D) then move += right end
		if UserInputService:IsKeyDown(Enum.KeyCode.Space) then move += Vector3.new(0, 1, 0) end
		if UserInputService:IsKeyDown(Enum.KeyCode.LeftControl) then move -= Vector3.new(0, 1, 0) end
		bodyVelocity.Velocity = move * flySpeed
		if bodyGyro then bodyGyro.CFrame = cam.CFrame end
	end
end)

player.CharacterAdded:Connect(function(c)
	character = c
	humanoid = c:WaitForChild("Humanoid")
	rootPart = c:WaitForChild("HumanoidRootPart")
	if flying then startFlying() end
end)

-- Enable Stuff Tab
local EnableTab = Window:Tab({Title = "Enable", Icon = "archive", Locked = false})

local EnableStuffSection = EnableTab:Section({
	Title = "Player",
	Box = true,
	Opened = false
})

local customWalkSpeed = 0
local speedConnection = nil

EnableStuffSection:Slider({
	Title = "Walk Speed",
	Desc = "",
	Flag = "walkspeed",
	Step = 1,
	Value = {Min = 0, Max = 200, Default = 0},
	Callback = function(value)
		customWalkSpeed = value
	end
})

local function startCFrameSpeed()
	if speedConnection then speedConnection:Disconnect() end
	speedConnection = RunService.Heartbeat:Connect(function()
		local hum = character and character:FindFirstChild("Humanoid")
		local root = character and character:FindFirstChild("HumanoidRootPart")
		if not hum or not root or hum.MoveDirection.Magnitude == 0 then return end
		if flying then return end
		local moveDirection = hum.MoveDirection
		if moveDirection.Magnitude > 0 then
			local velocity = moveDirection * customWalkSpeed
			local deltaTime = RunService.Heartbeat:Wait()
			local newPosition = root.Position + velocity * deltaTime
			local currentRotation = root.CFrame - root.CFrame.Position
			root.CFrame = CFrame.new(newPosition) * currentRotation
		end
	end)
end

startCFrameSpeed()

player.CharacterAdded:Connect(function(newChar)
	character = newChar
	task.wait(1)
	startCFrameSpeed()
end)

local noclipEnabled = false
local noclipConnection = nil

local function setCharacterCollisions(char, collidable)
	if not char then return end
	for _, part in ipairs(char:GetDescendants()) do
		if part:IsA("BasePart") then
			pcall(function()
				part.CanCollide = collidable
			end)
		end
	end
end

local function enableNoclip()
	noclipEnabled = true
	local function noclipStep()
		local char = player.Character
		if not char then return end
		for _, part in ipairs(char:GetDescendants()) do
			if part:IsA("BasePart") then
				pcall(function() part.CanCollide = false end)
			end
		end
	end
	noclipConnection = RunService.Stepped:Connect(noclipStep)
	if player.Character then
		setCharacterCollisions(player.Character, false)
	end
end

local function disableNoclip()
	noclipEnabled = false
	if noclipConnection then
		noclipConnection:Disconnect()
		noclipConnection = nil
	end
	if player.Character then
		setCharacterCollisions(player.Character, true)
	end
end

EnableStuffSection:Toggle({
	Title = "Noclip",
	Desc = "",
	Flag = "noclip",
	Icon = "",
	Type = "Toggle",
	Default = false,
	Callback = function(state)
		if state then
			enableNoclip()
		else
			disableNoclip()
		end
	end
})

EnableStuffSection:Toggle({
	Title = "Fly",
	Desc = "",
	Flag = "flytoggle",
	Icon = "",
	Type = "Toggle",
	Default = false,
	Callback = function(state)
		if state then
			startFlying()
		else
			stopFlying()
		end
	end
})

EnableStuffSection:Slider({
	Title = "Fly Speed",
	Desc = "",
	Flag = "flyslider",
	Step = 1,
	Value = {Min = 10, Max = 200, Default = 50},
	Callback = function(value)
		flySpeed = value
	end
})

if Admins[player.UserId] then

	local ServerSection = EnableTab:Section({
		Title = "Server",
		Box = true,
		Opened = false
	})

	ServerSection:Toggle({
		Title = "Auto-Rejoin",
		Desc = "",
		Flag = "autorejoin",
		Default = true,
		Callback = function(enabled)
			if enabled then
				_G.AutoRejoin = true
				getgenv().RejoinConnection = game:GetService("CoreGui").RobloxPromptGui.promptOverlay.ChildAdded:Connect(function(child)
					if child.Name == "ErrorPrompt" and child:FindFirstChild("MessageArea") and child.MessageArea:FindFirstChild("ErrorFrame") then
						game:GetService("TeleportService"):Teleport(game.PlaceId)
					end
				end)
				WindUI:Notify({
					Title = "Auto-Rejoin",
					Content = "Enabled - Will auto-rejoin on disconnect",
					Duration = 3,
					Icon = "check"
				})
			else
				_G.AutoRejoin = false
				if getgenv().RejoinConnection then
					getgenv().RejoinConnection:Disconnect()
					getgenv().RejoinConnection = nil
				end
				WindUI:Notify({
					Title = "Auto-Rejoin",
					Content = "Disabled",
					Duration = 3,
					Icon = "x"
				})
			end
		end
	})

	local serverCodeInput = ""

	ServerSection:Input({
		Title = "Server Code",
		Desc = "",
		Flag = "servercode",
		Value = "",
		InputIcon = "hash",
		Type = "Input",
		Placeholder = "Job Id",
		Callback = function(textVal)
			serverCodeInput = textVal
		end
	})

	ServerSection:Button({
		Title = "Join Server",
		Justify = "Center",
		IconAlign = "Right",
		Desc = "",
		Icon = "check",
		Callback = function()
			if not serverCodeInput or serverCodeInput == "" then
				WindUI:Notify({
					Title = "Error",
					Content = "Please enter a server code first!",
					Duration = 4,
					Icon = "x"
				})
				return
			end
			local cleanCode = serverCodeInput:gsub("%s+", ""):gsub('"', ""):gsub("'", ""):gsub("`", "")
			WindUI:Notify({
				Title = "Joining Server...",
				Content = "Attempting to join: " .. cleanCode,
				Duration = 5,
				Icon = "loader"
			})
			local TeleportService = game:GetService("TeleportService")
			local placeId = game.PlaceId
			pcall(function()
				TeleportService:TeleportToPlaceInstance(placeId, cleanCode, player)
			end)
			task.wait(2)
			WindUI:Notify({
				Title = "Joining...",
				Content = "If nothing happens, the code may be invalid or server is full",
				Duration = 5,
				Icon = "alert-triangle"
			})
		end
	})

end


-- settings tab
local SettingsTab = Window:Tab({
	Title = "Settings",
	Icon = "settings",
	Locked = false,
})

local UIKeybindsSection = SettingsTab:Section({ 
	Title = "UI Keybinds",
	Box = true,
	Opened = true,
})

UIKeybindsSection:Keybind({
	Title = "UI Toggle Key",
	Desc = "Key to open/close the UI",
	Value = "V",
	Callback = function(v)
		Window:SetToggleKey(Enum.KeyCode[v])
	end
})
